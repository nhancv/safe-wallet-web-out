{"version":3,"file":"static/chunks/9916.de3b68bc432d584b.js","mappings":"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","sources":["webpack://_N_E/./src/features/recovery/services/recovery-state.ts","webpack://_N_E/./src/components/common/Mui/index.tsx","webpack://_N_E/./src/features/recovery/components/RecoveryModal/index.tsx","webpack://_N_E/./src/features/recovery/hooks/useRecoveryTxNotification.ts","webpack://_N_E/./src/features/recovery/components/RecoveryContext/useRecoveryState.ts","webpack://_N_E/../../node_modules/@gnosis.pm/zodiac/dist/esm/index.js","webpack://_N_E/./src/features/recovery/services/proxies.ts","webpack://_N_E/./src/features/recovery/services/delay-modifier.ts","webpack://_N_E/./src/features/recovery/components/RecoveryContext/useRecoveryDelayModifiers.ts","webpack://_N_E/./src/features/recovery/components/RecoveryContext/useRecoveryPendingTxs.ts","webpack://_N_E/./src/features/recovery/components/RecoveryContext/useRecoverySuccessEvents.ts","webpack://_N_E/./src/features/recovery/components/RecoveryContext/RecoveryContextHooks.tsx","webpack://_N_E/./src/features/recovery/components/Recovery/LazyRecovery.tsx"],"sourcesContent":["import { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'\nimport memoize from 'lodash/memoize'\nimport { getMultiSendCallOnlyDeployment } from '@safe-global/safe-deployments'\nimport { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'\nimport type { Delay } from '@gnosis.pm/zodiac'\nimport type { TransactionAddedEvent } from '@gnosis.pm/zodiac/dist/cjs/types/Delay'\nimport { toBeHex, type JsonRpcProvider, type TransactionReceipt } from 'ethers'\nimport { trimTrailingSlash } from '@/utils/url'\nimport { sameAddress } from '@safe-global/utils/utils/addresses'\nimport { isMultiSendCalldata } from '@/utils/transaction-calldata'\nimport { decodeMultiSendData } from '@safe-global/protocol-kit/dist/src/utils'\n\nexport const MAX_RECOVERER_PAGE_SIZE = 100\n\ntype AddedEvent = TransactionAddedEvent.Log\nexport type RecoveryQueueItem = AddedEvent & {\n  timestamp: bigint\n  validFrom: bigint\n  expiresAt: bigint | null\n  isMalicious: boolean\n  executor: string\n}\n\nexport type RecoveryStateItem = {\n  address: string\n  recoverers: Array<string>\n  expiry: bigint\n  delay: bigint\n  txNonce: bigint\n  queueNonce: bigint\n  queue: Array<RecoveryQueueItem>\n}\n\nexport type RecoveryState = Array<RecoveryStateItem>\n\nexport function _isMaliciousRecovery({\n  chainId,\n  version,\n  safeAddress,\n  transaction,\n}: {\n  chainId: string\n  version: SafeState['version']\n  safeAddress: string\n  transaction: Pick<AddedEvent['args'], 'to' | 'data'>\n}) {\n  const BASE_MULTI_SEND_CALL_ONLY_VERSION = '1.3.0'\n\n  const isMultiSend = isMultiSendCalldata(transaction.data)\n  const transactions = isMultiSend ? decodeMultiSendData(transaction.data) : [transaction]\n\n  if (!isMultiSend) {\n    // Calling the Safe itself\n    return !sameAddress(transaction.to, safeAddress)\n  }\n\n  const multiSendDeployment =\n    getMultiSendCallOnlyDeployment({ network: chainId, version: version ?? undefined }) ??\n    getMultiSendCallOnlyDeployment({ network: chainId, version: BASE_MULTI_SEND_CALL_ONLY_VERSION })\n\n  if (!multiSendDeployment) {\n    return true\n  }\n\n  const multiSendAddress = multiSendDeployment.networkAddresses[chainId] ?? multiSendDeployment.defaultAddress\n\n  // Calling official MultiSend contract with a batch of transactions to the Safe itself\n  return (\n    !sameAddress(transaction.to, multiSendAddress) ||\n    transactions.some((transaction) => !sameAddress(transaction.to, safeAddress))\n  )\n}\n\nexport const _getRecoveryQueueItemTimestamps = async ({\n  delayModifier,\n  transactionAdded,\n  delay,\n  expiry,\n}: {\n  delayModifier: Delay\n  transactionAdded: AddedEvent\n  delay: bigint\n  expiry: bigint\n}): Promise<Pick<RecoveryQueueItem, 'timestamp' | 'validFrom' | 'expiresAt'>> => {\n  const timestamp = BigInt(await delayModifier.txCreatedAt(transactionAdded.args.queueNonce))\n  const validFrom = timestamp + delay\n  const expiresAt =\n    expiry === BigInt(0)\n      ? null // Never expires\n      : (validFrom + expiry) * BigInt(1000)\n\n  return {\n    timestamp: timestamp * BigInt(1000),\n    validFrom: validFrom * BigInt(1000),\n    expiresAt,\n  }\n}\n\nexport const _getSafeCreationReceipt = memoize(\n  async ({\n    transactionService,\n    safeAddress,\n    provider,\n  }: {\n    transactionService: string\n    safeAddress: string\n    provider: JsonRpcProvider\n  }): Promise<TransactionReceipt | null> => {\n    const url = `${trimTrailingSlash(transactionService)}/api/v1/safes/${safeAddress}/creation/`\n\n    const { transactionHash } = await fetch(url).then((res) => {\n      if (res.ok && res.status === 200) {\n        return res.json() as Promise<{ transactionHash: string } & unknown>\n      } else {\n        throw new Error('Error fetching Safe creation details')\n      }\n    })\n\n    return provider.getTransactionReceipt(transactionHash)\n  },\n  ({ transactionService, safeAddress }) => transactionService + safeAddress,\n)\n\nconst queryAddedTransactions = async (\n  delayModifier: Delay,\n  queueNonce: bigint,\n  txNonce: bigint,\n  transactionService: string,\n  provider: JsonRpcProvider,\n  safeAddress: string,\n) => {\n  if (queueNonce === txNonce) {\n    // There are no queued txs\n    return []\n  }\n\n  // We filter for the valid nonces while fetching the event logs.\n  // The nonce has to be one between the current queueNonce and the txNonce.\n  const diff = queueNonce - txNonce\n  const queryNonces = Array.from({ length: Number(diff) }, (_, idx) => {\n    return toBeHex(BigInt(txNonce + BigInt(idx)), 32)\n  })\n\n  const transactionAddedFilter = delayModifier.filters.TransactionAdded() as TransactionAddedEvent.Filter\n\n  const topics = await transactionAddedFilter.getTopicFilter()\n  topics[1] = queryNonces\n\n  const { blockNumber } = (await _getSafeCreationReceipt({ transactionService, provider, safeAddress }))!\n\n  // @ts-expect-error\n  return await delayModifier.queryFilter(topics, blockNumber, 'latest')\n}\n\nconst getRecoveryQueueItem = async ({\n  delayModifier,\n  transactionAdded,\n  delay,\n  expiry,\n  provider,\n  chainId,\n  version,\n  safeAddress,\n}: {\n  delayModifier: Delay\n  transactionAdded: AddedEvent\n  delay: bigint\n  expiry: bigint\n  provider: JsonRpcProvider\n  chainId: string\n  version: SafeState['version']\n  safeAddress: string\n}): Promise<RecoveryQueueItem> => {\n  const [timestamps, receipt] = await Promise.all([\n    _getRecoveryQueueItemTimestamps({\n      delayModifier,\n      transactionAdded,\n      delay,\n      expiry,\n    }),\n    provider.getTransactionReceipt(transactionAdded.transactionHash),\n  ])\n\n  const isMalicious = _isMaliciousRecovery({\n    chainId,\n    version,\n    safeAddress,\n    transaction: transactionAdded.args,\n  })\n\n  return {\n    ...transactionAdded,\n    ...timestamps,\n    isMalicious,\n    executor: receipt!.from,\n  }\n}\n\nexport const _getRecoveryStateItem = async ({\n  delayModifier,\n  transactionService,\n  safeAddress,\n  provider,\n  chainId,\n  version,\n}: {\n  delayModifier: Delay\n  transactionService: string\n  safeAddress: string\n  provider: JsonRpcProvider\n  chainId: string\n  version: SafeState['version']\n}): Promise<RecoveryStateItem> => {\n  const [[recoverers], expiry, delay, txNonce, queueNonce] = await Promise.all([\n    delayModifier.getModulesPaginated(SENTINEL_ADDRESS, MAX_RECOVERER_PAGE_SIZE),\n    delayModifier.txExpiration(),\n    delayModifier.txCooldown(),\n    delayModifier.txNonce(),\n    delayModifier.queueNonce(),\n  ])\n\n  const queuedTransactionsAdded = await queryAddedTransactions(\n    delayModifier,\n    BigInt(queueNonce),\n    BigInt(txNonce),\n    transactionService,\n    provider,\n    safeAddress,\n  )\n\n  const queue = await Promise.all(\n    queuedTransactionsAdded.map((transactionAdded) => {\n      return getRecoveryQueueItem({\n        delayModifier,\n        transactionAdded,\n        delay: BigInt(delay),\n        expiry: BigInt(expiry),\n        provider,\n        chainId,\n        version,\n        safeAddress,\n      })\n    }),\n  )\n\n  return {\n    address: await delayModifier.getAddress(),\n    recoverers,\n    expiry: BigInt(expiry),\n    delay: BigInt(delay),\n    txNonce: BigInt(txNonce),\n    queueNonce: BigInt(queueNonce),\n    queue: queue.filter((item) => !item.removed),\n  }\n}\n\nexport function getRecoveryState({\n  delayModifiers,\n  ...rest\n}: {\n  delayModifiers: Array<Delay>\n  transactionService: string\n  safeAddress: string\n  provider: JsonRpcProvider\n  chainId: string\n  version: SafeState['version']\n}): Promise<RecoveryState> {\n  return Promise.all(delayModifiers.map((delayModifier) => _getRecoveryStateItem({ delayModifier, ...rest })))\n}\n","export * from \"/app/apps/web/src/components/common/Mui/index.tsx\"","import { Backdrop, Fade } from '@mui/material'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { useRouter } from 'next/router'\nimport type { ReactElement } from 'react'\n\nimport { useRecoveryQueue } from '@/features/recovery/hooks/useRecoveryQueue'\nimport { RecoveryInProgressCard } from '../RecoveryCards/RecoveryInProgressCard'\nimport { RecoveryProposalCard } from '../RecoveryCards/RecoveryProposalCard'\nimport useIsSafeOwner from '@/hooks/useIsSafeOwner'\nimport { useIsRecoverer } from '@/features/recovery/hooks/useIsRecoverer'\nimport madProps from '@/utils/mad-props'\nimport useLocalStorage from '@/services/local-storage/useLocalStorage'\nimport useWallet from '@/hooks/wallets/useWallet'\nimport useSafeInfo from '@/hooks/useSafeInfo'\nimport { sameAddress } from '@safe-global/utils/utils/addresses'\nimport { useIsSidebarRoute } from '@/hooks/useIsSidebarRoute'\nimport type { RecoveryQueueItem } from '@/features/recovery/services/recovery-state'\n\nexport function InternalRecoveryModal({\n  isOwner,\n  isRecoverer,\n  queue,\n  wallet,\n  isSidebarRoute = true,\n}: {\n  isOwner: boolean\n  isRecoverer: boolean\n  queue: Array<RecoveryQueueItem>\n  wallet: ReturnType<typeof useWallet>\n  isSidebarRoute?: boolean\n}): ReactElement {\n  const { wasProposalDismissed, dismissProposal } = useDidDismissProposal()\n  const { wasInProgressDismissed, dismissInProgress } = useDidDismissInProgress()\n\n  const [modal, setModal] = useState<ReactElement | null>(null)\n  const router = useRouter()\n\n  const next = queue[0]\n\n  // Close modal\n  const onClose = () => {\n    setModal(null)\n  }\n\n  // Trigger modal\n  useEffect(() => {\n    if (!isSidebarRoute) {\n      return\n    }\n\n    setModal(() => {\n      if (next && (isOwner || isRecoverer) && !wasInProgressDismissed(next.transactionHash)) {\n        const onCloseWithDismiss = () => {\n          dismissInProgress(next.transactionHash)\n          onClose()\n        }\n\n        return <RecoveryInProgressCard onClose={onCloseWithDismiss} recovery={next} />\n      }\n\n      if (wallet?.address && isRecoverer && !wasProposalDismissed(wallet.address)) {\n        const onCloseWithDismiss = () => {\n          dismissProposal(wallet.address)\n          onClose()\n        }\n\n        return <RecoveryProposalCard onClose={onCloseWithDismiss} />\n      }\n\n      return null\n    })\n  }, [\n    dismissInProgress,\n    dismissProposal,\n    isRecoverer,\n    isOwner,\n    next,\n    queue.length,\n    router.pathname,\n    wallet,\n    wasInProgressDismissed,\n    wasProposalDismissed,\n    isSidebarRoute,\n  ])\n\n  // Close modal on navigation\n  useEffect(() => {\n    router.events.on('routeChangeComplete', onClose)\n    return () => {\n      router.events.off('routeChangeComplete', onClose)\n    }\n  }, [router])\n\n  return (\n    <Fade in={!!modal}>\n      <Backdrop open={!!modal} sx={{ zIndex: 3, bgcolor: ({ palette }) => palette.background.main }}>\n        {modal}\n      </Backdrop>\n    </Fade>\n  )\n}\n\nconst useSidebar = () => {\n  const [isSidebarRoute] = useIsSidebarRoute()\n  return isSidebarRoute\n}\n\nexport const RecoveryModal = madProps(InternalRecoveryModal, {\n  isOwner: useIsSafeOwner,\n  isRecoverer: useIsRecoverer,\n  queue: useRecoveryQueue,\n  wallet: useWallet,\n  isSidebarRoute: useSidebar,\n})\n\nexport function useDidDismissProposal() {\n  const LS_KEY = 'dismissedRecoveryProposals'\n\n  type Recoverer = string\n  type DismissedProposalCache = { [chainId: string]: { [safeAddress: string]: Recoverer } }\n\n  const { safe, safeAddress } = useSafeInfo()\n  const chainId = safe.chainId\n\n  const [dismissedProposals, setDismissedProposals] = useLocalStorage<DismissedProposalCache>(LS_KEY)\n\n  // Cache dismissal of proposal modal\n  const dismissProposal = useCallback(\n    (recovererAddress: string) => {\n      const dismissed = dismissedProposals?.[chainId] ?? {}\n\n      setDismissedProposals({\n        ...(dismissedProposals ?? {}),\n        [chainId]: {\n          ...dismissed,\n          [safeAddress]: recovererAddress,\n        },\n      })\n    },\n    [dismissedProposals, chainId, safeAddress, setDismissedProposals],\n  )\n\n  const wasProposalDismissed = useCallback(\n    (recovererAddress: string) => {\n      // If no proposals, is recoverer and didn't ever dismiss\n      return sameAddress(dismissedProposals?.[chainId]?.[safeAddress], recovererAddress)\n    },\n    [chainId, dismissedProposals, safeAddress],\n  )\n\n  return { wasProposalDismissed, dismissProposal }\n}\n\nexport function useDidDismissInProgress() {\n  type TxHash = string\n  type DismissedInProgressCache = { [chainId: string]: { [safeAddress: string]: TxHash } }\n\n  const { safe, safeAddress } = useSafeInfo()\n  const chainId = safe.chainId\n\n  const dismissedInProgress = useRef<DismissedInProgressCache>({})\n\n  // Cache dismissal of in-progress modal\n  const dismissInProgress = useCallback(\n    (txHash: string) => {\n      const dismissed = dismissedInProgress.current?.[chainId] ?? {}\n\n      dismissedInProgress.current = {\n        ...dismissedInProgress.current,\n        [chainId]: {\n          ...dismissed,\n          [safeAddress]: txHash,\n        },\n      }\n    },\n    [chainId, safeAddress],\n  )\n\n  const wasInProgressDismissed = useCallback(\n    (txHash: string) => {\n      // If proposal and did not notify during current session of Safe\n      return sameAddress(txHash, dismissedInProgress.current?.[chainId]?.[safeAddress])\n    },\n    [chainId, safeAddress],\n  )\n\n  return { wasInProgressDismissed, dismissInProgress }\n}\n","import { useEffect } from 'react'\n\nimport { formatError } from '@safe-global/utils/utils/formatters'\nimport { showNotification } from '@/store/notificationsSlice'\nimport { useAppDispatch } from '@/store'\nimport useSafeAddress from '../../../hooks/useSafeAddress'\nimport { RecoveryEvent, RecoveryTxType, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'\nimport { useCurrentChain } from '../../../hooks/useChains'\nimport { isWalletRejection } from '@/utils/wallets'\nimport { getExplorerLink } from '@safe-global/utils/utils/gateway'\n\nconst SUCCESS_EVENTS = [\n  RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET,\n  RecoveryEvent.PROCESSED,\n  RecoveryEvent.SUCCESS,\n]\n\nconst RecoveryTxNotifications = {\n  [RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET]: 'Confirm the execution in your wallet.',\n  [RecoveryEvent.PROCESSING]: 'Validating...',\n  [RecoveryEvent.PROCESSED]: 'Successfully validated. Loading...',\n  [RecoveryEvent.REVERTED]: 'Reverted. Please check your gas settings.',\n  [RecoveryEvent.FAILED]: 'Failed.',\n  [RecoveryEvent.SUCCESS]: 'Successfully executed.',\n}\n\nconst RecoveryTxNotificationTitles = {\n  [RecoveryTxType.PROPOSAL]: 'Account recovery proposal',\n  [RecoveryTxType.EXECUTION]: 'Account recovery',\n  [RecoveryTxType.SKIP_EXPIRED]: 'Account recovery cancellation',\n}\n\nexport function useRecoveryTxNotifications(): void {\n  const dispatch = useAppDispatch()\n  const chain = useCurrentChain()\n  const safeAddress = useSafeAddress()\n\n  /**\n   * Show notifications of a recovery transaction's lifecycle\n   */\n\n  useEffect(() => {\n    if (!chain?.blockExplorerUriTemplate) {\n      return\n    }\n\n    const entries = Object.entries(RecoveryTxNotifications) as Array<[keyof typeof RecoveryTxNotifications, string]>\n\n    const unsubFns = entries.map(([event, notification]) =>\n      recoverySubscribe(event, async (detail) => {\n        const isSuccess = SUCCESS_EVENTS.includes(event)\n        const isError = 'error' in detail\n        if (isError && isWalletRejection(detail.error)) return\n\n        const txHash = 'txHash' in detail ? detail.txHash : undefined\n        const recoveryTxHash = 'recoveryTxHash' in detail ? detail.recoveryTxHash : undefined\n        const groupKey = txHash || recoveryTxHash || ''\n\n        const title = RecoveryTxNotificationTitles[detail.txType]\n        const message = isError ? `${notification} ${formatError(detail.error)}` : notification\n\n        const link = txHash ? getExplorerLink(txHash, chain.blockExplorerUriTemplate) : undefined\n\n        dispatch(\n          showNotification({\n            title,\n            message,\n            detailedMessage: isError ? detail.error.message : undefined,\n            groupKey,\n            variant: isError ? 'error' : isSuccess ? 'success' : 'info',\n            link,\n          }),\n        )\n      }),\n    )\n\n    return () => {\n      unsubFns.forEach((unsub) => unsub())\n    }\n  }, [dispatch, safeAddress, chain?.blockExplorerUriTemplate])\n}\n","import { useCallback, useEffect, useState } from 'react'\nimport type { Delay } from '@gnosis.pm/zodiac'\n\nimport useAsync from '@safe-global/utils/hooks/useAsync'\nimport { useCurrentChain } from '@/hooks/useChains'\nimport useSafeInfo from '@/hooks/useSafeInfo'\nimport { useWeb3ReadOnly } from '@/hooks/wallets/web3'\nimport useIntervalCounter from '@/hooks/useIntervalCounter'\nimport { getRecoveryState } from '@/features/recovery/services/recovery-state'\nimport { useAppDispatch } from '@/store'\nimport { isCustomTxInfo, isMultiSendTxInfo, isTransactionListItem } from '@/utils/transaction-guards'\nimport { sameAddress } from '@safe-global/utils/utils/addresses'\nimport { addListener } from '@reduxjs/toolkit'\nimport { txHistorySlice } from '@/store/txHistorySlice'\nimport { RecoveryEvent, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'\nimport type { AsyncResult } from '@safe-global/utils/hooks/useAsync'\nimport type { RecoveryState } from '@/features/recovery/services/recovery-state'\n\nconst REFRESH_DELAY = 5 * 60 * 1_000 // 5 minutes\n\nexport function useRecoveryState(delayModifiers?: Array<Delay>): AsyncResult<RecoveryState> {\n  const web3ReadOnly = useWeb3ReadOnly()\n  const chain = useCurrentChain()\n  const { safe, safeAddress } = useSafeInfo()\n  const dispatch = useAppDispatch()\n\n  // Reload recovery data every REFRESH_DELAY\n  const [counter] = useIntervalCounter(REFRESH_DELAY)\n\n  // Reload recovery data when manually triggered\n  const [refetchDep, setRefetchDep] = useState(false)\n  const refetch = useCallback(() => {\n    setRefetchDep((prev) => !prev)\n  }, [])\n\n  // Reload recovery data when a Recoverer transaction occurs\n  useEffect(() => {\n    return recoverySubscribe(RecoveryEvent.PROCESSED, refetch)\n  }, [refetch])\n\n  // Reload recovery data when a Delay Modifier is interacted with\n  useEffect(() => {\n    if (!delayModifiers || delayModifiers.length === 0) {\n      return\n    }\n\n    // We leverage a listener instead of useAsync dependencies because there are\n    // that need be loaded before we can initially fetch the recovery state\n    const listener = dispatch(\n      addListener({\n        // Listen to history polls (only occuring when the txHistoryTag changes)\n        actionCreator: txHistorySlice.actions.set,\n        effect: async (action) => {\n          // Get the most recent transaction\n          const [latestTx] = action.payload.data?.results.filter(isTransactionListItem) ?? []\n\n          if (!latestTx) {\n            return\n          }\n\n          const { txInfo } = latestTx.transaction\n\n          const isDelayModiferTx = (\n            await Promise.all(\n              delayModifiers.map(async (delayModifier) => {\n                const address = await delayModifier.getAddress()\n                return isCustomTxInfo(txInfo) && sameAddress(txInfo.to.value, address)\n              }),\n            )\n          ).some(Boolean)\n\n          // Refetch if the most recent transaction was with a Delay Modifier or MultiSend\n          // (Multiple Delay Modifier settings changes are batched into a MultiSend)\n          if (isDelayModiferTx || isMultiSendTxInfo(txInfo)) {\n            refetch()\n          }\n        },\n      }),\n    )\n\n    // Types are incorrect, but this ensures type safety\n    const unsubscribe =\n      listener instanceof Function\n        ? (listener as unknown as typeof listener.payload.unsubscribe)\n        : listener.payload.unsubscribe\n\n    return unsubscribe\n  }, [safe.chainId, delayModifiers, refetch, dispatch])\n\n  return useAsync<RecoveryState>(\n    () => {\n      if (!delayModifiers || delayModifiers.length === 0 || !chain?.transactionService || !web3ReadOnly) {\n        return\n      }\n\n      return getRecoveryState({\n        delayModifiers,\n        transactionService: chain.transactionService,\n        safeAddress,\n        provider: web3ReadOnly,\n        chainId: safe.chainId,\n        version: safe.version,\n      })\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      delayModifiers,\n      counter,\n      refetchDep,\n      chain?.transactionService,\n      web3ReadOnly,\n      safeAddress,\n      safe.chainId,\n      safe.version,\n    ],\n    false,\n  )\n}\n","\nexport { ContractVersions } from \"/app/node_modules/@gnosis.pm/zodiac/dist/esm/contracts.js\"\nexport { KnownContracts } from \"/app/node_modules/@gnosis.pm/zodiac/dist/esm/factory/types.js\"\nexport { getModuleInstance } from \"/app/node_modules/@gnosis.pm/zodiac/dist/esm/factory/moduleDeployer.js\"","import type { JsonRpcProvider } from 'ethers'\nimport { Contract } from 'ethers'\n\n// zodiac-safe-app used as reference for proxy detection\n// @see https://github.com/gnosis/zodiac-safe-app/blob/e5d6d3d251d128245104ddc638e26d290689bb14/packages/app/src/utils/modulesValidation.ts\n\nexport function isGenericProxy(bytecode: string): boolean {\n  if (bytecode.length !== 92) {\n    return false\n  }\n\n  return bytecode.startsWith('0x363d3d373d3d3d363d73') && bytecode.endsWith('5af43d82803e903d91602b57fd5bf3')\n}\n\nexport function getGenericProxyMasterCopy(bytecode: string): string {\n  return '0x' + bytecode.slice(22, 62)\n}\n\nexport function isGnosisProxy(bytecode: string): boolean {\n  return (\n    bytecode.toLowerCase() ===\n    '0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032'\n  )\n}\n\nexport async function getGnosisProxyMasterCopy(address: string, provider: JsonRpcProvider): Promise<string> {\n  const gnosisProxyAbi = ['function masterCopy() external view returns (address)']\n  const gnosisProxyContract = new Contract(address, gnosisProxyAbi, provider)\n\n  const [masterCopy] = await gnosisProxyContract.masterCopy()\n\n  return masterCopy\n}\n","import { ContractVersions, getModuleInstance, KnownContracts } from '@gnosis.pm/zodiac'\nimport { SENTINEL_ADDRESS } from '@safe-global/protocol-kit/dist/src/utils/constants'\nimport type { Delay, SupportedNetworks } from '@gnosis.pm/zodiac'\nimport { type JsonRpcProvider, isAddress } from 'ethers'\nimport { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'\n\nimport { sameAddress } from '@safe-global/utils/utils/addresses'\nimport { getGenericProxyMasterCopy, getGnosisProxyMasterCopy, isGenericProxy, isGnosisProxy } from './proxies'\nimport { MAX_RECOVERER_PAGE_SIZE } from './recovery-state'\n\nexport async function _getZodiacContract(\n  chainId: string,\n  moduleAddress: string,\n  provider: JsonRpcProvider,\n): Promise<string | undefined> {\n  if (!isAddress(moduleAddress)) return\n\n  const bytecode = await provider.getCode(moduleAddress)\n\n  if (isGenericProxy(bytecode)) {\n    const masterCopy = getGenericProxyMasterCopy(bytecode)\n    return await _getZodiacContract(chainId, masterCopy, provider)\n  }\n\n  if (isGnosisProxy(bytecode)) {\n    const masterCopy = await getGnosisProxyMasterCopy(moduleAddress, provider)\n    return await _getZodiacContract(chainId, masterCopy, provider)\n  }\n\n  const zodiacChainContracts = ContractVersions[Number(chainId) as SupportedNetworks]\n  const zodiacContract = Object.entries(zodiacChainContracts).find(([, addresses]) => {\n    return Object.values(addresses).some((address) => {\n      return sameAddress(address, moduleAddress)\n    })\n  })\n\n  return zodiacContract?.[0]\n}\n\nasync function isOfficialDelayModifier(chainId: string, moduleAddress: string, provider: JsonRpcProvider) {\n  const zodiacContract = await _getZodiacContract(chainId, moduleAddress, provider)\n  return zodiacContract === KnownContracts.DELAY\n}\n\nexport async function _isOfficialRecoveryDelayModifier(\n  chainId: string,\n  delayModifier: Delay,\n  provider: JsonRpcProvider,\n) {\n  // Zodiac-deployed Delay Modifiers only have other Zodiac contracts added as modules\n  // If Delay Modifier only has non-Zodiac contracts as modules, it's a recovery-specific Delay Modifier\n  const [modules] = await delayModifier.getModulesPaginated(SENTINEL_ADDRESS, MAX_RECOVERER_PAGE_SIZE)\n\n  if (modules.length === 0) {\n    return false\n  }\n\n  const types = await Promise.all(modules.map((module) => _getZodiacContract(chainId, module, provider)))\n\n  const knownContracts = Object.values(KnownContracts)\n  return types.every((type) => !knownContracts.includes(type as KnownContracts))\n}\n\nexport async function getRecoveryDelayModifiers(\n  chainId: string,\n  modules: SafeState['modules'],\n  provider: JsonRpcProvider,\n): Promise<Array<Delay>> {\n  if (!modules) {\n    return []\n  }\n\n  const delayModifiers = await Promise.all(\n    modules.map(async ({ value }) => {\n      const isDelayModifier = await isOfficialDelayModifier(chainId, value, provider)\n      return isDelayModifier && getModuleInstance(KnownContracts.DELAY, value, provider)\n    }),\n  ).then((instances) => instances.filter(Boolean) as Array<Delay>)\n\n  const recoveryDelayModifiers = await Promise.all(\n    delayModifiers.map(async (delayModifier) => {\n      // TODO: Fetches \"recoverers\" of Delay Modifier, but we later fetch them again\n      // in useRecoveryState. Could optimise this by returning the recoverers here\n      const isRecoveryDelayModifier = await _isOfficialRecoveryDelayModifier(chainId, delayModifier, provider)\n      return isRecoveryDelayModifier && delayModifier\n    }),\n  ).then((instances) => instances.filter(Boolean) as Array<Delay>)\n\n  return recoveryDelayModifiers\n}\n","import type { Delay } from '@gnosis.pm/zodiac'\nimport { type SafeState } from '@safe-global/store/gateway/AUTO_GENERATED/safes'\n\nimport { getRecoveryDelayModifiers } from '@/features/recovery/services/delay-modifier'\nimport useAsync from '@safe-global/utils/hooks/useAsync'\nimport useSafeInfo from '@/hooks/useSafeInfo'\nimport { useWeb3ReadOnly } from '@/hooks/wallets/web3'\nimport { getDeployedSpendingLimitModuleAddress } from '@/services/contracts/spendingLimitContracts'\nimport type { AsyncResult } from '@safe-global/utils/hooks/useAsync'\nimport { useIsRecoverySupported } from '../../hooks/useIsRecoverySupported'\n\nfunction isOnlySpendingLimitEnabled(chainId: string, modules: SafeState['modules']) {\n  if (modules && modules.length > 1) return false\n  const spendingLimit = getDeployedSpendingLimitModuleAddress(chainId, modules)\n  return !!spendingLimit\n}\n\nexport function useRecoveryDelayModifiers(): AsyncResult<Delay[]> {\n  const supportsRecovery = useIsRecoverySupported()\n  const web3ReadOnly = useWeb3ReadOnly()\n  const { safe, safeAddress } = useSafeInfo()\n\n  return useAsync<Array<Delay>>(\n    () => {\n      // Don't fetch if only spending limit module is enabled\n      if (\n        supportsRecovery &&\n        web3ReadOnly &&\n        safe.modules &&\n        safe.modules.length > 0 &&\n        !isOnlySpendingLimitEnabled(safe.chainId, safe.modules)\n      ) {\n        return getRecoveryDelayModifiers(safe.chainId, safe.modules, web3ReadOnly)\n      }\n    },\n    // Only fetch delay modifiers again if the chain or enabled modules of current Safe changes\n    // Need to check length of modules array to prevent new request every time Safe info polls\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [safeAddress, safe.chainId, safe.modules?.length, web3ReadOnly, supportsRecovery],\n    false,\n  )\n}\n","import { useEffect, useState } from 'react'\n\nimport { RecoveryEvent, recoverySubscribe } from '@/features/recovery/services/recoveryEvents'\nimport type { RecoveryTxType } from '@/features/recovery/services/recoveryEvents'\n\nexport type PendingRecoveryTransactions = {\n  [recoveryTxHash: string]: {\n    status: RecoveryEvent\n    txType: RecoveryTxType\n  }\n}\n\nconst pendingStatuses: { [_key in RecoveryEvent]: RecoveryEvent | null } = {\n  [RecoveryEvent.PROCESSING_BY_SMART_CONTRACT_WALLET]: null,\n  [RecoveryEvent.PROCESSING]: RecoveryEvent.PROCESSING,\n  [RecoveryEvent.PROCESSED]: RecoveryEvent.PROCESSED,\n  [RecoveryEvent.SUCCESS]: null,\n  [RecoveryEvent.REVERTED]: null,\n  [RecoveryEvent.FAILED]: null,\n}\n\nexport function useRecoveryPendingTxs() {\n  const [pending, setPending] = useState<PendingRecoveryTransactions>({})\n\n  useEffect(() => {\n    const unsubFns = Object.entries(pendingStatuses).map(([event, status]) =>\n      recoverySubscribe(event as RecoveryEvent, (detail) => {\n        const recoveryTxHash = 'recoveryTxHash' in detail && detail.recoveryTxHash\n\n        if (!recoveryTxHash) {\n          return\n        }\n\n        setPending((prev) => {\n          if (status === null) {\n            const { [recoveryTxHash]: _, ...rest } = prev\n            return rest\n          }\n\n          return {\n            ...prev,\n            [recoveryTxHash]: {\n              txType: detail.txType,\n              status,\n            },\n          }\n        })\n      }),\n    )\n\n    return () => {\n      unsubFns.forEach((unsub) => unsub())\n    }\n  }, [])\n\n  return pending\n}\n","import { useEffect } from 'react'\n\nimport { RecoveryEvent, RecoveryTxType, recoveryDispatch } from '@/features/recovery/services/recoveryEvents'\nimport type { RecoveryState } from '@/features/recovery/services/recovery-state'\nimport type { useRecoveryPendingTxs } from './useRecoveryPendingTxs'\n\nexport function useRecoverySuccessEvents(\n  pending: ReturnType<typeof useRecoveryPendingTxs>,\n  recoveryState?: RecoveryState,\n): void {\n  useEffect(() => {\n    const pendingEntries = Object.entries(pending)\n\n    if (!recoveryState || recoveryState.length === 0 || pendingEntries.length === 0) {\n      return\n    }\n\n    pendingEntries.forEach(([recoveryTxHash, { txType, status }]) => {\n      // Transaction successfully executed, waiting for recovery state to be loaded again\n      if (status !== RecoveryEvent.PROCESSED) {\n        return\n      }\n\n      const isQueued = recoveryState.some(({ queue }) => queue.some(({ args }) => args.txHash === recoveryTxHash))\n\n      // Only queued proposals or executions/cancellations removed from the queue\n      if (isQueued && txType !== RecoveryTxType.PROPOSAL) {\n        return\n      }\n\n      recoveryDispatch(RecoveryEvent.SUCCESS, {\n        recoveryTxHash,\n        txType,\n      })\n    })\n  }, [pending, recoveryState])\n}\n","import { useEffect } from 'react'\nimport { useRecoveryState } from './useRecoveryState'\nimport { useRecoveryDelayModifiers } from './useRecoveryDelayModifiers'\nimport { useRecoveryPendingTxs } from './useRecoveryPendingTxs'\nimport { useRecoverySuccessEvents } from './useRecoverySuccessEvents'\nimport store from '.'\n\nfunction RecoveryContextHooks(): null {\n  const [delayModifiers, delayModifiersError, delayModifiersLoading] = useRecoveryDelayModifiers()\n  const [recoveryState, recoveryStateError, recoveryStateLoading] = useRecoveryState(delayModifiers)\n  const pending = useRecoveryPendingTxs()\n\n  useRecoverySuccessEvents(pending, recoveryState)\n\n  const data = recoveryState\n  const error = delayModifiersError || recoveryStateError\n  const loading = delayModifiersLoading || recoveryStateLoading\n\n  useEffect(() => {\n    store.setStore({\n      state: [data, error, loading],\n      pending,\n    })\n  }, [data, error, loading, pending])\n\n  return null\n}\n\nexport default RecoveryContextHooks\n","import { RecoveryModal } from '@/features/recovery/components/RecoveryModal'\nimport { useRecoveryTxNotifications } from '@/features/recovery/hooks/useRecoveryTxNotification'\nimport RecoveryContextHooks from '../RecoveryContext/RecoveryContextHooks'\n\nfunction LazyRecovery() {\n  useRecoveryTxNotifications()\n\n  return (\n    <>\n      <RecoveryContextHooks />\n      <RecoveryModal />\n    </>\n  )\n}\n\nexport default LazyRecovery\n"],"names":["MAX_RECOVERER_PAGE_SIZE","_getRecoveryQueueItemTimestamps","delayModifier","transactionAdded","delay","expiry","timestamp","BigInt","txCreatedAt","args","queueNonce","validFrom","expiresAt","memoize","transactionService","safeAddress","provider","url","trimTrailingSlash","transactionHash","fetch","then","res","ok","status","json","getTransactionReceipt","queryAddedTransactions","txNonce","queryNonces","Array","from","length","Number","_","idx","toBeHex","transactionAddedFilter","filters","TransactionAdded","topics","getTopicFilter","blockNumber","_getSafeCreationReceipt","queryFilter","getRecoveryQueueItem","chainId","version","timestamps","receipt","Promise","all","isMalicious","_isMaliciousRecovery","getMultiSendCallOnlyDeployment","multiSendDeployment","transaction","isMultiSend","isMultiSendCalldata","data","transactions","decodeMultiSendData","sameAddress","to","network","undefined","BASE_MULTI_SEND_CALL_ONLY_VERSION","multiSendAddress","networkAddresses","defaultAddress","some","executor","_getRecoveryStateItem","recoverers","getModulesPaginated","SENTINEL_ADDRESS","txExpiration","txCooldown","queuedTransactionsAdded","queue","map","address","getAddress","filter","item","removed","getRecoveryState","delayModifiers","rest","RecoveryModal","madProps","InternalRecoveryModal","isOwner","isRecoverer","wallet","isSidebarRoute","wasProposalDismissed","dismissProposal","useDidDismissProposal","safe","useSafeInfo","dismissedProposals","setDismissedProposals","useLocalStorage","LS_KEY","useCallback","dismissed","recovererAddress","wasInProgressDismissed","dismissInProgress","useDidDismissInProgress","dismissedInProgress","useRef","current","txHash","modal","setModal","useState","router","useRouter","next","onClose","useEffect","RecoveryInProgressCard","onCloseWithDismiss","recovery","RecoveryProposalCard","pathname","events","on","off","Fade","in","Backdrop","open","sx","zIndex","bgcolor","palette","background","main","useIsSafeOwner","useIsRecoverer","useRecoveryQueue","useWallet","useSidebar","useIsSidebarRoute","SUCCESS_EVENTS","RecoveryEvent","PROCESSING_BY_SMART_CONTRACT_WALLET","PROCESSED","SUCCESS","RecoveryTxNotifications","PROCESSING","REVERTED","FAILED","RecoveryTxNotificationTitles","RecoveryTxType","PROPOSAL","EXECUTION","SKIP_EXPIRED","getGnosisProxyMasterCopy","gnosisProxyContract","Contract","gnosisProxyAbi","masterCopy","_getZodiacContract","moduleAddress","isAddress","bytecode","getCode","isGenericProxy","startsWith","endsWith","slice","getGenericProxyMasterCopy","isGnosisProxy","toLowerCase","zodiacContract","Object","entries","ContractVersions","find","addresses","values","isOfficialDelayModifier","KnownContracts","DELAY","_isOfficialRecoveryDelayModifier","modules","types","module","knownContracts","every","includes","type","getRecoveryDelayModifiers","value","getModuleInstance","instances","Boolean","pendingStatuses","RecoveryContextHooks","delayModifiersError","delayModifiersLoading","useRecoveryDelayModifiers","supportsRecovery","useIsRecoverySupported","web3ReadOnly","useWeb3ReadOnly","useAsync","getDeployedSpendingLimitModuleAddress","recoveryState","recoveryStateError","recoveryStateLoading","useRecoveryState","chain","useCurrentChain","dispatch","useAppDispatch","counter","useIntervalCounter","refetchDep","setRefetchDep","refetch","prev","recoverySubscribe","listener","addListener","actionCreator","txHistorySlice","actions","set","effect","action","latestTx","payload","results","isTransactionListItem","txInfo","isCustomTxInfo","isMultiSendTxInfo","Function","unsubscribe","pending","useRecoveryPendingTxs","setPending","unsubFns","event","recoveryTxHash","detail","txType","forEach","unsub","pendingEntries","recoveryDispatch","error","loading","store","setStore","state","LazyRecovery","useRecoveryTxNotifications","useSafeAddress","blockExplorerUriTemplate","notification","isSuccess","isError","isWalletRejection","groupKey","title","message","formatError","link","getExplorerLink","showNotification","detailedMessage","variant"],"sourceRoot":"","ignoreList":[5]}